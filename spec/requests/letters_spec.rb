# frozen_string_literal: true

require 'rails_helper'

# This spec was generated by rspec-rails when you ran the scaffold generator.
# It demonstrates how one might use RSpec to test the controller code that
# was generated by Rails when you ran the scaffold generator.
#
# It assumes that the implementation code is generated by the rails scaffold
# generator. If you are using any extension libraries to generate different
# controller code, this generated spec may or may not pass.
#
# It only uses APIs available in rails and/or rspec-rails. There are a number
# of tools you can use to make these specs even more expressive, but we're
# sticking to rails and rspec-rails APIs to keep things simple and stable.

RSpec.describe '/letters', type: :request do
  # This should return the minimal set of attributes required to create a valid
  # Letter. As you add validations to Letter, be sure to
  # adjust the attributes here as well.
  let(:valid_attributes) { {} }

  let(:invalid_attributes) { {} }

  # This should return the minimal set of values that should be in the headers
  # in order to pass any filters (e.g. authentication) defined in
  # LettersController, or in your router and rack
  # middleware. Be sure to keep this updated too.
  let(:valid_headers) { {} }

  describe 'GET /index' do
    it 'renders a successful response' do
      create_list(:public_letter, 3)
      Letter.reindex
      get letters_url, headers: valid_headers, as: :json
      expect(response).to be_successful
    end

    it 'renders only plblically avaliable letters' do
      create_list(:public_letter, 4)
      create_list(:old_letter, 3)
      create_list(:new_letter, 5)
      Letter.reindex
      get "#{letters_url}.json", headers: valid_headers, as: :json
      expect(Letter._public.count).to eq(4)
      expect(json[:letters].count).to eq(4)
      expect(Letter.count).to eq(12)
    end

    it 'renders paginated links in json response' do
      create_list(:public_letter, 10)
      Letter.reindex
      get "#{letters_url}.json?page=2&per_page=2"
      expect(json[:letters].count).to eq(2)
      expect(json[:meta][:links][:next]).to eq("#{letters_url}.json?page=3&per_page=2")
      expect(json[:meta][:links][:last]).to eq("#{letters_url}.json?page=5&per_page=2")
      expect(json[:meta][:links][:first]).to eq("#{letters_url}.json?page=1&per_page=2")
      expect(json[:meta][:links][:self]).to eq("#{letters_url}.json?page=2&per_page=2")
      expect(json[:meta][:page]).to eq(2)
      expect(json[:meta][:per_page]).to eq(2)
      expect(json[:meta][:page_count]).to eq(5)
      expect(json[:meta][:total_count]).to eq(10)
    end

    it 'includes pagination information in the headers' do
      create_list(:public_letter, 20)
      Letter.reindex
      get "#{letters_url}.json?page=3&per_page=5"
      links = response.headers['Link'].split(',')
      expect(links.count).to eq(5)
      expect(links[0]).to include('self')
      expect(links[0]).to include('letters.json?page=3&per_page=5')

      expect(links[1]).to include('first')
      expect(links[1]).to include('letters.json?page=1&per_page=5')

      expect(links[2]).to include('last')
      expect(links[2]).to include('letters.json?page=4&per_page=5')

      expect(links[3]).to include('next')
      expect(links[3]).to include('letters.json?page=4&per_page=5')

      expect(links[4]).to include('prev')
      expect(links[4]).to include('letters.json?page=2&per_page=5')

      expect(response.headers['X-Total-Count']).to eq(20)
    end

    it 'renders letters from specific recipients' do
      create_list(:public_letter, 5)
      create_list(:public_letter, 2, recipients: create_list(:person_entity, 1, label: 'Dominique Wilkins'))
      create_list(:public_letter, 3, recipients: create_list(:person_entity, 1, label: 'Spud Webb'))
      create_list(
        :public_letter,
        1,
        recipients: [Entity.find_by(label: 'Dominique Wilkins'), Entity.find_by(label: 'Spud Webb')]
      )
      Letter.reindex
      get "#{letters_url}.json?q=Dominique, Spud Webb&fields=recipients"
      expect(json[:letters].count).to eq(6)
    end
  end

  describe 'GET /show' do
    it 'renders a successful response' do
      letter = Letter.create! valid_attributes
      get letter_url(letter), as: :json
      expect(response).to be_successful
    end
  end

  describe 'POST /create' do
    context 'with valid parameters' do
      it 'creates a new Letter' do
        expect {
          post letters_url,
               params: { letter: valid_attributes }, headers: valid_headers, as: :json
        }.not_to change(Letter, :count)
        expect(response).to have_http_status(:not_implemented)
      end
    end
  end

  describe 'PATCH /update' do
    context 'with valid parameters' do
      it 'updates the requested letter' do
        letter = create(:letter)
        patch letter_url(letter),
              params: { letter: {} }, headers: valid_headers, as: :json
        expect(response).to have_http_status(:not_implemented)
      end
    end
  end

  describe 'DELETE /destroy' do
    it 'destroys the requested letter' do
      letter = create(:letter)
      expect {
        delete letter_url(letter), headers: valid_headers, as: :json
      }.not_to change(Letter, :count)
      expect(response).to have_http_status(:not_implemented)
    end
  end
end
